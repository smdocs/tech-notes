# Requirements for TMI (Messaging API)

### Overview
As we onboard more and more trading systems clients in TMS, there is going to be an ongoing need for multiple publishers and consumers consumers to use different messaging paradigms. We may need to support clients who needs streaming
- Logs generated by frontend applications or backend services
- User behavior data
- Application or system performance trace
- Business, application or system metrics data.
- Events that need immediate action.

### Objectives
Main design objectives of TMI messaging interface:
- <b>Fast and High-Throughput</b> : This is the top priority feature, without this capability, the system will be easily overwhelmed by flooding data continuously generated by hundreds of producers, it is expected that both enqueue and dequeue speed should be close to O(1) memory access.

- <b>Persistent and Durable</b> : Any data loss should be avoided as far as possible. Also, downstream consumer can crash therefore is common,should persist messages on disk longer than the maintenance(or system recovery) window, to let backend systems continue to consume messages when they are up again. Regarding durability, Luxun should ensure the persistence of the message even the service process crashes.

- <b>Separation of Producers and Consumers</b> : Luxun should separate messaging producers and consumers using pub-sub style exchange pattern, each one can work without knowing the existence of the others, such kind of loosely coupled architecture can make the whole system robust, horizontal scalable, and easy to maintain.

- <b>Realtime</b> : Messages produced by producer threads should be immediately visible to consumer threads, this feature is critical to event based system like Complex Event Processing(CEP) system.

- <b>Distributed</b> : Luxun should explicitly support partitioning messages over Luxun servers and distributing consumption over a cluster of consumer machines while maintaining per-partition ordering semantics.

- <b>Multiple Client Support</b> : Luxun system should support easy integration of clients from different kinds of platforms(such as Java, .Net, PHP, Ruby, Python, etc), it’s desirable that producers and consumers can be auto-generated from Luxun service interface, by leveraging technology like Thrift RPC.

- <b>Flexible consuming semantics</b> : Luxun should support typical consume once queue, fanout queue, and provides more flexible consuming mechanism like consuming by index.

- <b>Light Weight</b>: The footprint of Luxun binary should be light, and the interface exposed should be simple and be understandable by normal user. Zookeeper like distributed coordination should be avoided since many small or medium scale companies still can’t afford it, and the learning curve of zookeeker to average developers is still steep.

Underlying, TMI can expose functionality of the following components:

1. <b>Persistent Queue</b> : Physical implementation of logic topic, internally use memory mapped file, automatic paging and swapping algorithm, sliding window, index based access for fast queue operation while use memory in an efficient way.

2. <b>Thrift based Interface</b> : Simple RPC based API exposing queue service to external clients, exposing rich message level objects generated from the underlying data model.

3. <b>Producer Client</b> : Wrapper around underlying producing API, in order to provide simplified and uniform interface for developers, also provides advanced partitioning, batching, compression and asynchronous producing features.

4. <b>Consumer Client</b> : Wrapper around Luxun consuming API, provides simplified and stream style consuming interface for developers, supporting advanced distributed consuming, multi-threads concurrent consuming, group consuming features.

5. <b>Management and Monitoring</b> : Server management and JMX based monitoring interface.


[1](https://msdn.microsoft.com/en-us/library/aa480027.aspx)
[2](http://bulldog2011.github.io/blog/2013/01/23/big-queue-design/)
